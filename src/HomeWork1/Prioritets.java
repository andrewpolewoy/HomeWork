package HomeWork1;

public class Prioritets {

    public static void main(String[] args) {


        //   5 + 2 / 8 // = 5 сначала деление, потом сложение, дробная часть отбрасывается, так как переменные int(в этом и последующих примерах).
		//	 (5 + 2) / 8 // = 0 скобки поменяли приоритет (сначала сложение)
		//	 (5 + 2++) / 8 // = 0 скобки поменяли приоритет (сначала сложение) постфиксный инкремент увеличил значение на 1, но сохранил в отдельную переменную. То есть при вычислении считаем как 2.
		//	 (5 + 2++) / --8 // = 1 постфиксный инкремент увеличил значение на 1, но сохранил в отдельную переменную. То есть при вычислении считаем как 2. Префиксный же инкремент увменьшил значение на 1 и сохранил в эту же переменную (считаем как 7).
		//	 (5 * 2 >> 2++) /--8 // = 0 согласно таблице приоритетов сначала постфиксный инкремент увеличивает и сохраняет в отдельную переменную число 2 (при подсчете считаем как 2), затем умножение (результат 10), затем сдвиг вправо (результат 0) и деление на --8 (7).
		//	 (5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8 // = 1 сначала постфиксный инкремент (при подсчете остается 2), префиксный дикремент --8 (результат 7), потом умножение 22*2=44,затем сложение 5+7=12 потом сдвиг 44 на 2 (результат 11), теперь проверка условия 12>20(false) => условный оператор оставляет выражение после :. Итог 11 / 7.
		//	 (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8 //  не скомпилируется. сначала постфиксный инкремент (при подсчете остается 2), префиксный дикремент --8 (результат 7), потом умножение 22*2=44,затем сложение 5+7=12 потом сдвиг 44 на 2 (результат 11), теперь проверка условия 68 >= 68 (true) и 12>20(false) => условный оператор оставляет выражение после ":". Т.к. будет исспользовано выражение после ":", то для удобства компиляции не будем использовать выражение между знаками "?" и ":"(в противном случае компилятор ругается (согласно синтаксису тернарного оператора после 68 >=68 должен быть знак "?" и выбор значения через ":"))
		//	 6 - 2 > 3 && 12 * 12 <= 119 // = false сначала умножение (144), потом вычитание (4), сравнение 4 > 3 (true), сравнение 144 <= 119(false), логический оператор && короткая форма (в данном случае пришлось проверить оба выражения, т.к. первое true.
		//	 true && false // = false (аналогично) если бы первое было false, то выражение справа не проверялось бы.

        int a = 2;
        int b = 8;
        boolean c = true;
        System.out.println(5 + a / b);
        System.out.println((5 + a) / b);
        System.out.println((5 + a++) / b);
        a = 2;
        System.out.println((5 + a++) / --b);
        a = 2;
        b = 8;
        System.out.println((5 * a >> a++) /--b);
        a = 2;
        b = 8;
        System.out.println((5 + 7 > 20 ? 68 : 22 * a >> a++) / --b);
        a = 2;
        b = 8;
      //  System.out.println((5 + 7 > 20 ? 68 >= 68  : 22 * a >> a++) / --b);
        System.out.println(6 - 2 > 3 && 12 * 12 <= 119);
        System.out.println(true && false);

    }
}
